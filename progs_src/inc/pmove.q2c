// pmove.qc - player movement code shred by both client and server, this file must be the same for both or prediction errors will happen!


/*
TODOs:

- make movement parameters cvars
- get rid of cl_ cvars controling speed
*/

#if 0

void (vector v1, vector v2, __inout vector cross) CrossProduct =
{
	cross[0] = v1[1]*v2[2] - v1[2]*v2[1];
	cross[1] = v1[2]*v2[0] - v1[0]*v2[2];
	cross[2] = v1[0]*v2[1] - v1[1]*v2[0];
};


// movement parameters
static float	pm_stopspeed = 100;
static float	pm_maxspeed = 300;
static float	pm_duckspeed = 100;
static float	pm_accelerate = 10;
static float	pm_airaccelerate = 0;
static float	pm_wateraccelerate = 10;
static float	pm_friction = 6;
static float	pm_waterfriction = 1;
static float	pm_waterspeed = 400;

entity pm_passent;

// all of the locals will be zeroed before each pmove, just to make damn 
// sure we don't have any differences when running on client or server
typedef struct
{
	vector		origin;			// full float precision
	vector		velocity;		// full float precision

	vector		forward, right, up;
	float		frametime;

	float		groundsurface;
	float		groundsurface_flags;
	float		groundplane;
	float		groundcontents;

	vector		previous_origin;
	float		ladder;
} pml_t;

pmove_t	pm;
pml_t	pml;

// pmove doesn't need to know about passent and contentmask
void(vector start, vector mins, vector maxs, vector end) pm_trace =
{
	if (pm_passent.health > 0)
		trace(start, mins, maxs, end, pm_passent, MASK_PLAYERSOLID);
	else
		trace(start, mins, maxs, end, pm_passent, MASK_DEADSOLID);
};

vector(float scale, vector veca, vector vecb) VectorMA =
{
	vector out;
	out[0] = veca[0] + scale * vecb[0];
	out[1] = veca[1] + scale * vecb[1];
	out[2] = veca[2] + scale * vecb[2];
	return out;
}

/*

  walking up a step should kill some velocity

*/

float(vector x, vector y) DotProduct2 =
{
	return (x[0] * y[0] + x[1] * y[1] + x[2] * y[2]);
};



/*
==================
PM_ClipVelocity

Slide off of the impacting object
returns the blocked flags (1 = floor, 2 = step / wall)
==================
*/
#define	STOP_EPSILON	0.1

void(vector in, vector normal, vector out, float overbounce) PM_ClipVelocity =
{
	local float	backoff, change, i;
	
	backoff = DotProduct2(in, normal);
	backoff = backoff * overbounce;

	change = normal[0] *backoff;
	out[0] = in[0] - change;
	if (out[0] > -STOP_EPSILON && out[0] < STOP_EPSILON)
		out[0] = 0;
	
	change = normal[1] *backoff;
	out[1] = in[1] - change;
	if (out[1] > -STOP_EPSILON && out[1] < STOP_EPSILON)
		out[1] = 0;
	
	change = normal[2] *backoff;
	out[2] = in[2] - change;
	if (out[2] > -STOP_EPSILON && out[2] < STOP_EPSILON)
		out[2] = 0;	
};




/*
==================
PM_StepSlideMove

Each intersection will try to step over the obstruction instead of
sliding along it.

Returns a new origin, velocity, and contact entity
Does not modify any world state?
==================
*/
#define	MIN_STEP_NORMAL	0.7		// can't step up onto very steep slopes
#define	MAX_CLIP_PLANES	5
void() PM_StepSlideMove_ =
{
	local float	bumpcount, numbumps, numplanes;
	local vector	planes[MAX_CLIP_PLANES];
	local vector	primal_velocity;
	local float		i, j, d;
	local vector	dir, end;
	local float		time_left;
	
	numbumps = 4;
	numplanes = 0;	
	primal_velocity = pml.velocity;
	time_left = pml.frametime;

	for( bumpcount = 0; bumpcount < numbumps; bumpcount++)
	{
		for(i = 0; i < 3; i++)
			end[i] = pml.origin[i] + time_left * pml.velocity[i];

		pm_trace(pml.origin, pm.mins, pm.maxs, end);

		if(trace_allsolid) // entity is trapped in another solid so don't build up falling damage
		{
			pml.velocity[2] = 0;
			return;
		}

		if(trace_fraction > 0) // actually covered some distance
		{
			pml.origin = trace_endpos;
			numplanes = 0;
		}

		if(trace_fraction == 1)
			 break;	// moved the entire distance

		// save entity for contact
		if(pm.numtouch < MAXTOUCH && trace_ent)
		{
			pm.touchents[pm.numtouch] = trace_ent;
			pm.numtouch = pm.numtouch +	1;
		}
		
		time_left = time_left - (time_left * trace_fraction);

		// slide along this plane
		
		if(numplanes >= MAX_CLIP_PLANES) // this shouldn't really happen
		{	
			pml.velocity = vec3_origin;
			break;
		}

		planes[numplanes] = trace_plane_normal;
		numplanes++;

//
// modify original_velocity so it parallels all of the clip planes
//
		for( i = 0; i < numplanes; i++ )
		{
			PM_ClipVelocity(pml.velocity, planes[i], pml.velocity, 1.01);
			for( j = 0; j < numplanes; j++ )
			{
				if(j != i)
				{
					if(DotProduct2(pml.velocity, planes[j]) < 0)
						break;	// not ok
				}
			}
			if(j == numplanes)
				break;
		}
		
		if(i != numplanes)
		{	// go along this plane
		}
		else
		{	// go along the crease
			if(numplanes != 2)
			{
				dprint("Pmove: clip velocity, numplanes == "); dprint(ftos(numplanes)); dprint("\n");
				pml.velocity = vec3_origin;
				break;
			}
			 CrossProduct( planes[0], planes[1], dir );
			d = DotProduct2( dir, pml.velocity );
			pml.velocity = dir * d;
		}
		//
		// if velocity is against the original velocity, stop dead
		// to avoid tiny occilations in sloping corners
		//
		if(DotProduct2(pml.velocity, primal_velocity) <= 0)
		{
			pml.velocity = vec3_origin;
			break;
		}
	}

	if (pm.s.pm_time)
	{
		pml.velocity = primal_velocity;
	}
};

/*
==================
PM_StepSlideMove

==================
*/
void() PM_StepSlideMove =
{
	local vector	start_o, start_v, down_o, down_v;
	local float		down_dist, up_dist;
	local vector	up, down;

	start_o = pml.origin;
	start_v = pml.velocity;

	PM_StepSlideMove_();

	down_o = pml.origin;
	down_v = pml.velocity;

	up = start_o;
	up[2] = up[2] + STEPSIZE;

	pm_trace(up, pm.mins, pm.maxs, up);
	if(trace_allsolid)
		return; // can't step up

	// try sliding above
	pml.origin = up;
	pml.velocity = start_v;

	PM_StepSlideMove_();

	// push down the final amount
	down = pml.origin;
	down[2] = down[2] - STEPSIZE;
	pm_trace(pml.origin, pm.mins, pm.maxs, down);
	if(!trace_allsolid)
	{
		pml.origin = trace_endpos;
	}

	up = pml.origin;

	// decide which one went farther
    down_dist = (down_o[0] - start_o[0]) * (down_o[0] - start_o[0]) + (down_o[1] - start_o[1]) * (down_o[1] - start_o[1]);
    up_dist = (up[0] - start_o[0]) * (up[0] - start_o[0]) + (up[1] - start_o[1])*(up[1] - start_o[1]);

	if ( (down_dist > up_dist) || (trace_plane_normal[2] < MIN_STEP_NORMAL) )
	{
		pml.origin = down_o;
		pml.velocity = down_v;
		return;
	}
	//!! Special case
	// if we were walking along a plane, then we need to copy the Z over
	pml.velocity[2] = down_v[2];
};


/*
==================
PM_Friction

Handles both ground friction and water friction
==================
*/
void() PM_Friction =
{
	local vector	vel;
	local float		speed, newspeed, control;
	local float		friction;
	local float		drop;
	
	vel = pml.velocity;
	
	speed = sqrt( (vel[0] * vel[0]) + (vel[1] * vel[1]) + (vel[2] * vel[2]));
	if(speed < 1)
	{
		vel[0] = 0;
		vel[1] = 0;
		pml.velocity = vel;
		return;
	}

	drop = 0;

	// apply ground friction
	if( (pm.groundentity && pml.groundsurface && !(pml.groundsurface_flags & SURF_SLICK) ) || (pml.ladder) )
	{
		friction = pm_friction;
		
		if(speed < pm_stopspeed)
			control = pm_stopspeed;
		else
			control = speed;
		
		drop += (control * friction * pml.frametime);
	}

	// apply water friction
	if (pm.waterlevel && !pml.ladder)
		drop += (speed * pm_waterfriction * pm.waterlevel * pml.frametime);

	// scale the velocity
	newspeed = speed - drop;
	if (newspeed < 0)
	{
		newspeed = 0;
	}
	newspeed /= speed;

	vel[0] = vel[0] * newspeed;
	vel[1] = vel[1] * newspeed;
	vel[2] = vel[2] * newspeed;
};


/*
==============
PM_Accelerate

Handles user intended acceleration
==============
*/
void(vector wishdir, float wishspeed, float accel) PM_Accelerate =
{
	local float		i;
	local float		addspeed, accelspeed, currentspeed;

	currentspeed = DotProduct2(pml.velocity, wishdir);
	
	addspeed = wishspeed - currentspeed;
	if (addspeed <= 0)
		return;
	
	accelspeed = accel * pml.frametime * wishspeed;
	if ( accelspeed > addspeed )
		accelspeed = addspeed;
	
	for(i = 0; i < 3; i++)
		pml.velocity[i] += (accelspeed * wishdir[i]);	
};


void(vector wishdir, float wishspeed, float accel) PM_AirAccelerate =
{
	local float		i;
	local float		addspeed, accelspeed, currentspeed, wishspd;
	
	wishspd = wishspeed;
	if(wishspd > 30)
		wishspd = 30;
	
	currentspeed = DotProduct2(pml.velocity, wishdir);
	
	addspeed = wishspd - currentspeed;
	if(addspeed <= 0)
		return;
	
	accelspeed = (accel * wishspeed * pml.frametime);
	if (accelspeed > addspeed)
		accelspeed = addspeed;
	
	for (i=0 ; i<3 ; i++)
		pml.velocity[i] += (accelspeed * wishdir[i]);	
};

/*
=============
PM_AddCurrents
=============
*/
float(vector wishvel) PM_AddCurrents  =
{
	local vector	v;
	local float		s;

	//
	// account for ladders
	//

	if (pml.ladder)
	{
		if(fabs(pml.velocity[2]) <= 200)
		{
			if ((pm.viewangles[0] <= -15) && (pm.cmd.forwardmove > 0))
				wishvel[2] = 200;
			else if ((pm.viewangles[0] >= 15) && (pm.cmd.forwardmove > 0))
				wishvel[2] = -200;
			else if (pm.cmd.upmove > 0)
				wishvel[2] = 200;
			else if (pm.cmd.upmove < 0)
				wishvel[2] = -200;
			else
				wishvel[2] = 0;

			// limit horizontal speed when on a ladder
			if (wishvel[0] < -25)
				wishvel[0] = -25;
			else if (wishvel[0] > 25)
				wishvel[0] = 25;

			if (wishvel[1] < -25)
				wishvel[1] = -25;
			else if (wishvel[1] > 25)
				wishvel[1] = 25;
		}
	}


	//
	// add water currents
	//

	if (pm.watertype & MASK_CURRENT)
	{
		v = vec3_origin;

		// watertype with all currents set = doom
		if (pm.watertype & CONTENTS_CURRENT_0)
			v[0] = v[0] + 1;
		if (pm.watertype & CONTENTS_CURRENT_90)
			v[1] = v[1] + 1;
		if (pm.watertype & CONTENTS_CURRENT_180)
			v[0] = v[0] - 1;
		if (pm.watertype & CONTENTS_CURRENT_270)
			v[1] = v[1] - 1;
		if (pm.watertype & CONTENTS_CURRENT_UP)
			v[2] = v[2] + 1;
		if (pm.watertype & CONTENTS_CURRENT_DOWN)
			v[2] = v[2] - 1;

		s = pm_waterspeed;
		if ((pm.waterlevel == 1) && (pm.groundentity != -1))
			s /= 2;

		wishvel = VectorMA(wishvel, s, v);
	}

	//
	// add conveyor belt velocities
	//

	if (pm.groundentity != -1)
	{
		v = vec3_origin;

		if (pml.groundcontents & CONTENTS_CURRENT_0)
			v[0] = v[0] + 1;
		if (pml.groundcontents & CONTENTS_CURRENT_90)
			v[1] = v[1] + 1;
		if (pml.groundcontents & CONTENTS_CURRENT_180)
			v[0] = v[0] - 1;
		if (pml.groundcontents & CONTENTS_CURRENT_270)
			v[1] = v[1] - 1;
		if (pml.groundcontents & CONTENTS_CURRENT_UP)
			v[2] = v[2] + 1;
		if (pml.groundcontents & CONTENTS_CURRENT_DOWN)
			v[2] = v[2] - 1;

		wishvel = VectorMA(wishvel, 100 /* pm.groundentity->speed */, v);	
	}
	return wishvel;
};


/*
===================
PM_WaterMove

===================
*/
void() PM_WaterMove =
{
	local vector	wishvel, wishdir;
	local float		wishspeed, i;

//
// user intentions
//
	for ( i = 0; i < 3; i++ )
		wishvel[i] = (pml.forward[i] * pm.cmd.forwardmove + pml.right[i] * pm.cmd.sidemove);

	if( !pm.cmd.forwardmove && !pm.cmd.sidemove && !pm.cmd.upmove )
		wishvel[2] = wishvel[2] - 60;		// drift towards bottom
	else
		wishvel[2] = wishvel[2] + pm.cmd.upmove;

	wishvel = PM_AddCurrents( wishvel );
	wishdir = wishvel;
	wishspeed = VectorNormalize(wishdir);

	if( wishspeed > pm_maxspeed )
	{
		wishvel = wishvel * (pm_maxspeed/wishspeed);
		wishspeed = pm_maxspeed;
	}
	
	wishspeed = wishspeed * 0.5;

	PM_Accelerate(wishdir, wishspeed, pm_wateraccelerate);
	PM_StepSlideMove();
};


/*
===================
PM_AirMove

===================
*/
void() PM_AirMove =
{

	local vector	wishvel, wishdir;
	local float		fmove, smove;
	local float		wishspeed, maxspeed;
	local float		i;
	
	fmove = pm.cmd.forwardmove;
	smove = pm.cmd.sidemove;
	
	for(i = 0; i < 2; i++)
		wishvel[i] = ((pml.forward[i] * fmove) + (pml.right[i] * smove));
	wishvel[2] = 0;

	wishvel = PM_AddCurrents (wishvel);

	wishdir = wishvel;
	wishspeed = VectorNormalize(wishdir);

//
// clamp to server defined max speed
//
	if( (pm.s.pm_flags & PMF_DUCKED) )	
		maxspeed = pm_duckspeed : pm_maxspeed;
	else
		maxspeed = pm_maxspeed;

	if( wishspeed > maxspeed )
	{
		wishvel = wishvel * (maxspeed/wishspeed);
		wishspeed = maxspeed;
	}
	
	if( pml.ladder ) // on ladder
	{
		PM_Accelerate(wishdir, wishspeed, pm_accelerate);
		if (!wishvel[2])
		{
			if (pml.velocity[2] > 0)
			{
				pml.velocity[2] -= pm.s.gravity * pml.frametime;
				if (pml.velocity[2] < 0)
					pml.velocity[2]  = 0;
			}
			else
			{
				pml.velocity[2] += pm.s.gravity * pml.frametime;
				if (pml.velocity[2] > 0)
					pml.velocity[2]  = 0;
			}
		}
		PM_StepSlideMove();
	}
	else if( pm.groundentity ) // walking on ground
	{	
		pml.velocity[2] = 0; //!!! this is before the accel
		PM_Accelerate (wishdir, wishspeed, pm_accelerate);

		// fix for negative gravity fields
		if(pm.s.gravity > 0)
			pml.velocity[2] = 0;
		else
			pml.velocity[2] = pml.velocity[2] - (pm.s.gravity * pml.frametime);

		if (!pml.velocity[0] && !pml.velocity[1])
			return;
		
		PM_StepSlideMove ();
	}
	else // not on ground, so little effect on velocity
	{	
		if( pm_airaccelerate )
			PM_AirAccelerate (wishdir, wishspeed, pm_accelerate);
		else
			PM_Accelerate (wishdir, wishspeed, 1);
		
		// add gravity
		pml.velocity[2] = pml.velocity[2] - (pm.s.gravity * pml.frametime);
		PM_StepSlideMove();
	}
};



/*
=============
PM_CatagorizePosition
=============
*/
void PM_CatagorizePosition (void)
{
	local vector	point;
	local float		cont, sample1, sample2;

	// if the player hull point one unit down is solid, the player is on ground
	// see if standing on something solid
	point[0] = pml.origin[0];
	point[1] = pml.origin[1];
	point[2] = pml.origin[2] - 0.25;
	
	if( pml.velocity[2] > 180 ) 
	{
		pm.s.pm_flags &= ~PMF_ON_GROUND;
		pm.groundentity = NULL;
	}
	else
	{
		pm.trace(pml.origin, pm.mins, pm.maxs, point);
		pml.groundplane = trace_plane;
		pml.groundsurface = trace_surface;
		pml.groundcontents = trace_contents;

		if(!trace.ent || (trace_plane_normal[2] < 0.7 && !trace_startsolid) )
		{
			pm.groundentity = NULL;
			pm.s.pm_flags &= ~PMF_ON_GROUND;
		}
		else
		{
			pm.groundentity = trace_ent;

			// hitting solid ground will end a waterjump
			if (pm.s.pm_flags & PMF_TIME_WATERJUMP)
			{
				pm.s.pm_flags &= ~(PMF_TIME_WATERJUMP | PMF_TIME_LAND | PMF_TIME_TELEPORT);
				pm.s.pm_time = 0;
			}

			if( !(pm.s.pm_flags & PMF_ON_GROUND) ) // just hit the ground
			{	
				pm.s.pm_flags |= PMF_ON_GROUND;
				
				// don't do landing time if we were just going down a slope
				if( pml.velocity[2] < -200 )
				{
					pm.s.pm_flags |= PMF_TIME_LAND;
					// don't allow another jump for a little while
					if (pml.velocity[2] < -400)
						pm.s.pm_time = 25;	
					else
						pm.s.pm_time = 18;
				}
			}
		}

		if( (pm.numtouch < MAXTOUCH) && trace.ent )
		{
			pm.touchents[pm.numtouch] = trace.ent;
			pm.numtouch = pm.numtouch + 1;
		}
	}

//
// get waterlevel, accounting for ducking
//
	pm.waterlevel = 0;
	pm.watertype = 0;

	sample2 = pm.viewheight - pm.mins[2];
	sample1 = sample2 / 2;

	point[2] = pml.origin[2] + pm.mins[2] + 1;	
	cont = PointContents(point);

	if(cont & MASK_WATER)
	{
		pm.watertype = cont;
		pm.waterlevel = 1;
		point[2] = pml.origin[2] + pm.mins[2] + sample1;
		cont = PointContents (point);
		if (cont & MASK_WATER)
		{
			pm.waterlevel = 2;
			point[2] = pml.origin[2] + pm.mins[2] + sample2;
			cont = PointContents (point);
			if (cont & MASK_WATER)
				pm.waterlevel = 3;
		}
	}
};


/*
=============
PM_CheckJump
=============
*/
void() PM_CheckJump =
{
	if (pm.s.pm_flags & PMF_TIME_LAND)
	{	// hasn't been long enough since landing to jump again
		return;
	}

	if (pm.cmd.upmove < 10)
	{	// not holding jump
		pm.s.pm_flags &= ~PMF_JUMP_HELD;
		return;
	}

	// must wait for jump to be released
	if (pm.s.pm_flags & PMF_JUMP_HELD)
		return;

	if (pm.s.pm_type == PM_DEAD)
		return;

	if (pm.waterlevel >= 2)
	{	// swimming, not jumping
		pm.groundentity = -1;

		if (pml.velocity[2] <= -300)
			return;

		if (pm.watertype == CONTENTS_WATER)
			pml.velocity[2] = 100;
		else if (pm.watertype == CONTENTS_SLIME)
			pml.velocity[2] = 80;
		else
			pml.velocity[2] = 50;
		return;
	}

	if (pm.groundentity == NULL)
		return;		// in air, so no effect

	pm.s.pm_flags |= PMF_JUMP_HELD;

	pm.groundentity = -1;
	pml.velocity[2] = pml.velocity[2] + 270;
	if (pml.velocity[2] < 270)
		pml.velocity[2] = 270;
};


/*
=============
PM_CheckSpecialMovement
=============
*/
void() PM_CheckSpecialMovement =
{
	local vector	spot, flatforward;
	local float		cont;

	if( pm.s.pm_time )
		return;

	pml.ladder = false;

	// check for ladder
	flatforward[0] = pml.forward[0];
	flatforward[1] = pml.forward[1];
	flatforward[2] = 0;
	flatforward = normalize(flatforward);

	spot = VectorMA(pml.origin, 1, flatforward);
	pm_trace(pml.origin, pm.mins, pm.maxs, spot);
	if ((trace_fraction < 1) && (trace.contents & CONTENTS_LADDER))
		pml.ladder = true;

	// check for water jump
	if(pm.waterlevel != 2)
		return;

	spot = VectorMA(pml.origin, 30, flatforward);
	spot[2] += 4;
	cont = PointContents(spot);
	if (!(cont & CONTENTS_SOLID))
		return;

	spot[2] += 16;
	cont = PointContents(spot);
	if (cont)
		return;
	
	// jump out of water
	VectorScale (flatforward, 50, pml.velocity);
	pml.velocity[2] = 350;

	pm.s.pm_flags |= PMF_TIME_WATERJUMP;
	pm.s.pm_time = 255;
};



/*
===============
PM_FlyMove
===============
*/
void(float doclip) PM_FlyMove =
{
	float	speed, drop, friction, control, newspeed;
	float	currentspeed, addspeed, accelspeed;
	int			i;
	vector		wishvel;
	float		fmove, smove;
	vector		wishdir;
	float		wishspeed;
	vector		end;
	trace_t	trace;

	pm.viewheight = 22;

	// friction

	speed = VectorLength (pml.velocity);
	if (speed < 1)
	{
		VectorCopy (vec3_origin, pml.velocity);
	}
	else
	{
		drop = 0;

		friction = pm_friction*1.5;	// extra friction
		control = speed < pm_stopspeed ? pm_stopspeed : speed;
		drop += control*friction*pml.frametime;

		// scale the velocity
		newspeed = speed - drop;
		if (newspeed < 0)
			newspeed = 0;
		newspeed /= speed;

		VectorScale (pml.velocity, newspeed, pml.velocity);
	}

	// accelerate
	fmove = pm.cmd.forwardmove;
	smove = pm.cmd.sidemove;
	
	VectorNormalize (pml.forward);
	VectorNormalize (pml.right);

	for (i=0 ; i<3 ; i++)
		wishvel[i] = pml.forward[i]*fmove + pml.right[i]*smove;
	wishvel[2] += pm.cmd.upmove;

	wishdir = wishvel;
	wishspeed = VectorNormalize(wishdir);

	//
	// clamp to server defined max speed
	//
	if (wishspeed > pm_maxspeed)
	{
		wishvel = wishvel * (pm_maxspeed/wishspeed);
		wishspeed = pm_maxspeed;
	}

	currentspeed = DotProduct2(pml.velocity, wishdir);
	addspeed = wishspeed - currentspeed;
	
	if (addspeed <= 0)
		return;
	
	accelspeed = pm_accelerate * pml.frametime * wishspeed;
	
	if (accelspeed > addspeed)
		accelspeed = addspeed;
	
	for( i = 0 ; i < 3 ; i++ )
		pml.velocity[i] += accelspeed * wishdir[i];	

	if( doclip ) 
	{
		for (i=0 ; i<3 ; i++)
			end[i] = pml.origin[i] + pml.frametime * pml.velocity[i];

		pm_trace(pml.origin, pm.mins, pm.maxs, end);
		pml.origin = trace.endpos;
	} 
	else 
	{
		// move
		pml.origin = VectorMA(pml.origin, pml.frametime, pml.velocity);
	}
};


/*
==============
PM_CheckDuck

Sets mins, maxs, and pm.viewheight
==============
*/
void() PM_CheckDuck =
{
	pm.mins[0] = -16;
	pm.mins[1] = -16;

	pm.maxs[0] = 16;
	pm.maxs[1] = 16;

	if (pm.s.pm_type == PM_GIB)
	{
		pm.mins[2] = 0;
		pm.maxs[2] = 16;
		pm.viewheight = 8;
		return;
	}

	pm.mins[2] = -24;

	if( pm.s.pm_type == PM_DEAD )
	{
		pm.s.pm_flags |= PMF_DUCKED;
	}
	else if( (pm.cmd.upmove < 0 && (pm.s.pm_flags & PMF_ON_GROUND)) )
	{	
		pm.s.pm_flags |= PMF_DUCKED; // duck
	}
	else
	{	
		// stand up if possible
		if( (pm.s.pm_flags & PMF_DUCKED) )
		{
			// try to stand up
			pm.maxs[2] = 32;
			pm_trace(pml.origin, pm.mins, pm.maxs, pml.origin);
			if(!trace_allsolid)
				pm.s.pm_flags &= ~PMF_DUCKED;
		}
	}

	if (pm.s.pm_flags & PMF_DUCKED)
	{
		pm.maxs[2] = 4;
		pm.viewheight = -2;
	}
	else
	{
		pm.maxs[2] = 32;
		pm.viewheight = 22;
	}
};


/*
==============
PM_DeadMove
==============
*/
void() PM_DeadMove =
{
	float	forward;

	if(pm.groundentity == -1)
		return;

	// extra friction
	forward = VectorLength( pml.velocity );
	forward = forward - 20;
	
	if (forward <= 0)
	{
		pml.velocity = vec3_origin;
	}
	else
	{
		pml.velocity = VectorNormalize( pml.velocity );
		pml.velocity = pml.velocity * forward;
	}
};


float() PM_GoodPosition =
{
	local vector	origin, end;
	local float 	i;

	if( pm.s.pm_type == PM_SPECTATOR )
		return true;

	for( i = 0 ; i < 3 ; i++ )
		origin[i] = end[i] = (pm.s.origin[i] * 0.125);
	
	pm_trace(origin, pm.mins, pm.maxs, end);

	return !trace_allsolid;
};

/*
================
PM_SnapPosition

On exit, the origin will have a value that is pre-quantized to the 0.125
precision of the network channel and in a valid position.
================
*/
void() PM_SnapPosition =
{
	local vector	sign;
	local float		i, j, bits;
	local vector	base;
	
	static float jitterbits[8] = {0,4,1,2,3,5,6,7}; // try all single bits first

	// snap velocity to eigths
	for( i = 0; i < 3; i++ )
		pm.s.velocity[i] = (pml.velocity[i] * 8); 

	for( i = 0; i < 3; i++ )
	{
		if (pml.origin[i] >= 0)
			sign[i] = 1;
		else 
			sign[i] = -1;
		pm.s.origin[i] = (pml.origin[i] * 8); // FIXME: round to int
		if ( (pm.s.origin[i] * 0.125) == pml.origin[i] )
			sign[i] = 0;
	}
	VectorCopy (pm.s.origin, base);

	// try all combinations
	for( j = 0 ; j < 8; j++ )
	{
		bits = jitterbits[j];
		pm.s.origin = base;

		for( i = 0 ; i < 3 ; i++ )
			if( bits & (1<<i) )
				pm.s.origin[i] = pm.s.origin[i] + sign[i];

		if( PM_GoodPosition() == true )
			return;
	}

	pm.s.origin = pml.previous_origin; // go back to the last position
	dprint( "Pmove: SnapPosition using previous_origin\n" );
};

/*
================
PM_InitialSnapPosition
================
*/
static float snapoffset[3] = { 0, -1, 1 };

void() PM_InitialSnapPosition =
{
	local float		x, y, z;
	local vector	base;
	
	base = pm.s.origin;

	for( z = 0; z < 3; z++ ) 
	{
		pm.s.origin[2] = base[2] + snapoffset[z];
		for( y = 0; y < 3; y++ ) 
		{
			pm.s.origin[1] = base[1] + snapoffset[y];
			for( x = 0; x < 3; x++ ) 
			{
				pm.s.origin[0] = base[0] + snapoffset[x];
				if (PM_GoodPosition() == true) 
				{
					pml.origin[0] = pm.s.origin[0] * 0.125;
					pml.origin[1] = pm.s.origin[1] * 0.125;
					pml.origin[2] = pm.s.origin[2] * 0.125;
					pml.previous_origin = pm.s.origin;
					return;
				}
			}
		}
	}
	dprint("Pmove: Bad InitialSnapPosition\n");
};


/*
================
PM_ClampAngles

Clamps player view angles so you cannot look upside down
================
*/
void() PM_ClampAngles =
{
	local float		temp, i;

	if( pm.s.pm_flags & PMF_TIME_TELEPORT )
	{
		pm.viewangles[1] = SHORT2ANGLE( pm.cmd.angles[1] + pm.s.delta_angles[1] );
		pm.viewangles[0] = 0;
		pm.viewangles[2] = 0;
	}
	else
	{
		// circularly clamp the angles with deltas
		for( i = 0 ; i < 3; i++ )
		{
			temp = pm.cmd.angles[i] + pm.s.delta_angles[i];
			pm.viewangles[i] = SHORT2ANGLE(temp);
		}

		// don't let the player look up or down more than 90 degrees
		if( (pm.viewangles[0] > 89 && pm.viewangles[0] < 180) )
			pm.viewangles[0] = 89;
		else if( (pm.viewangles[0] < 271 && pm.viewangles[0] >= 180) )
			pm.viewangles[0] = 271;
	}
		pml.forward = AnglesToForward( pm.viewangles );
		pml.right = AnglesToRight( pm.viewangles );
		pml.up = AnglesToUp( pm.viewangles );	
};


/*
================
ClearPmoveLocals

Zeroes all pmove locals
================
*/
void() ClearPmoveLocals() = 
{
	pml.origin = pml.velocity = vec3_origin;
	pml.forward = pml.right = pml.up = vec3_origin;
	pml.frametime = 0;
	pml.groundsurface = 0;
	pml.groundsurface_flags = 0;
	pml.groundplane = 0;
	pml.groundcontents = 0;
	pml.previous_origin  = vec3_origin;
	pml.ladder = false;
};

/*
================
PlayerMove

Can be called by either the server or the client
================
*/
void(/*pmove_t pmove*/) PlayerMove =
{
	local float 	msec;
	local vector	angles;
//	pm = pmove;

	// clear results
	pm.numtouch = 0;
	pm.viewangles = vec3_origin;
	pm.viewheight = 0;
	pm.groundentity = 0;
	pm.watertype = 0;
	pm.waterlevel = 0;

	// clear all pmove local vars
	ClearPmoveLocals();

	// convert origin and velocity to float values
	pml.origin[0] = pm.s.origin[0] * 0.125;
	pml.origin[1] = pm.s.origin[1] * 0.125;
	pml.origin[2] = pm.s.origin[2] * 0.125;

	pml.velocity[0] = pm.s.velocity[0] * 0.125;
	pml.velocity[1] = pm.s.velocity[1] * 0.125;
	pml.velocity[2] = pm.s.velocity[2] * 0.125;

	// save old org in case we get stuck
	pml.previous_origin = pm.s.origin;

	pml.frametime = pm.cmd.msec * 0.001;

	PM_ClampAngles();

	if( pm.s.pm_type == PM_SPECTATOR )
	{
		PM_FlyMove(false);
		PM_SnapPosition();
		return;
	}

	if( pm.s.pm_type >= PM_DEAD )
	{
		pm.cmd.forwardmove = 0;
		pm.cmd.sidemove = 0;
		pm.cmd.upmove = 0;
	}

	if( pm.s.pm_type == PM_FREEZE )
		return;		// no movement at all

	// set mins, maxs, and viewheight
	PM_CheckDuck();

	if( pm.snapinitial )
		PM_InitialSnapPosition();

	// set groundentity, watertype, and waterlevel
	PM_CatagorizePosition();

	if( pm.s.pm_type == PM_DEAD )
		PM_DeadMove();

	PM_CheckSpecialMovement();

	// drop timing counter
	if(pm.s.pm_time)
	{
		msec = pm.cmd.msec >> 3;
		if (!msec)
			msec = 1;
		if( msec >= pm.s.pm_time ) 
		{
			pm.s.pm_flags &= ~(PMF_TIME_WATERJUMP | PMF_TIME_LAND | PMF_TIME_TELEPORT);
			pm.s.pm_time = 0;
		}
		else
			pm.s.pm_time -= msec;
	}

	if( pm.s.pm_flags & PMF_TIME_TELEPORT )
	{	
		// teleport pause stays exactly in place
	}
	else if( pm.s.pm_flags & PMF_TIME_WATERJUMP )
	{	
		// waterjump has no control, but falls
		pml.velocity[2] = pml.velocity[2] - (pm.s.gravity * pml.frametime);
		
		if (pml.velocity[2] < 0)
		{	
			// cancel as soon as we are falling down again
			pm.s.pm_flags &= ~(PMF_TIME_WATERJUMP | PMF_TIME_LAND | PMF_TIME_TELEPORT);
			pm.s.pm_time = 0;
		}

		PM_StepSlideMove();
	}
	else
	{
		PM_CheckJump();
		PM_Friction();

		if( pm.waterlevel >= 2 )
		{
			PM_WaterMove (); // deep in water, try swimming
		}
		else 
		{
			angles = pm.viewangles;
			if (angles[0] > 180)
				angles[0] = angles[0] - 360;
			angles[0] = angles[0] / 3;

			pml.forward = AnglesToForward( angles );
			pml.right = AnglesToRight( angles );
			pml.up = AnglesToUp( angles );
			PM_AirMove();
		}
	}

	// set groundentity, watertype, and waterlevel for final spot
	PM_CatagorizePosition();
	PM_SnapPosition ();
};

#endif