/*
P R A G M A
Copyright (C) 2023 BraXi.

Quake 2 Engine 'Id Tech 2'
Copyright (C) 1997-2001 Id Software, Inc.
*/
// funcs.qc - func_ entities

/*
func_group			- qbsp entity, not used
func_wall			- This is just a solid wall if not inhibited
func_areaportal		- This is a non-visible object that divides the world into areas that are seperated when this portal is not activated.
func_object			- This is solid bmodel that will fall if it's support it removed.
*/


//
// spawnflags
//

//func_wall & func_object
float FUNC_SPAWNFLAG_TRIGGER_SPAWN = 1;
float FUNC_SPAWNFLAG_TOGGLE = 2;
float FUNC_SPAWNFLAG_START_ON = 4;
float FUNC_SPAWNFLAG_ANIMATED = 8;
float FUNC_SPAWNFLAG_ANIMATED_FAST = 16;



/*QUAKED func_group (0 0 0) ?
Used to group brushes together just for editor convenience.
removed in game
*/
float() SP_func_group =
{
	return false; // remove entity straight away
};

// ===================================================== 


/*QUAKED func_wall (0 .5 .8) ? TRIGGER_SPAWN TOGGLE START_ON ANIMATED ANIMATED_FAST
This is just a solid wall if not inhibited

TRIGGER_SPAWN	the wall will not be present until triggered
				it will then blink in to existance; it will
				kill anything that was in it's way

TOGGLE			only valid for TRIGGER_SPAWN walls
				this allows the wall to be turned on and off

START_ON		only valid for TRIGGER_SPAWN walls
				the wall will initially be present
*/
void(entity acti) func_wall_use =
{
	if (self.solid == SOLID_NOT)
	{
		self.solid = SOLID_BSP;
		self.svflags &= ~SVF_NOCLIENT;
		KillBox();
	}
	else
	{
		self.solid = SOLID_NOT;
		self.svflags |= SVF_NOCLIENT;
	}
	linkentity(self);

	if (!(self.spawnflags & FUNC_SPAWNFLAG_TOGGLE))
		self.use = null_use;
};

float() SP_func_wall =
{
	self.movetype = MOVETYPE_PUSH;
	setmodel(self, self.model);

	if (self.spawnflags & FUNC_SPAWNFLAG_ANIMATED)
		self.effects |= EF_ANIM_ALL;
	if (self.spawnflags & FUNC_SPAWNFLAG_ANIMATED_FAST)
		self.effects |= EF_ANIM_ALLFAST;

	// just a wall
	if ((self.spawnflags & 7) == 0)
	{
		self.solid = SOLID_BSP;
		linkentity(self);
		return true;
	}

	// it must be TRIGGER_SPAWN
	if (!(self.spawnflags & FUNC_SPAWNFLAG_TRIGGER_SPAWN))
	{
		dprint3("func_wall at ", vtos(self.origin), " missing TRIGGER_SPAWN\n");
		self.spawnflags |= FUNC_SPAWNFLAG_TRIGGER_SPAWN;
	}

	// yell if the spawnflags are odd
	if (self.spawnflags & FUNC_SPAWNFLAG_START_ON)
	{
		if (!(self.spawnflags & FUNC_SPAWNFLAG_TOGGLE))
		{
			dprint("func_wall START_ON without TOGGLE\n");
			self.spawnflags |= FUNC_SPAWNFLAG_TOGGLE;
		}
	}

	self.use = func_wall_use;
	if (self.spawnflags & FUNC_SPAWNFLAG_START_ON)
	{
		self.solid = SOLID_BSP;
	}
	else
	{
		self.solid = SOLID_NOT;
		self.svflags |= SVF_NOCLIENT;
	}
	linkentity(self);
	return true;
}

// ===================================================== 

/*QUAKED func_areaportal (0 0 0) ?

This is a non-visible object that divides the world into
areas that are seperated when this portal is not activated.
Usually enclosed in the middle of a door.
*/
void(entity activator) func_areaportal_use =
{
	self.count ^= 1;	// toggle state
	
	if( cvar("developer_script") > 0 )
		dprint5("portalstate: ", ftos(self.style)," = ", ftos(self.count), ";\n");

	SetAreaPortalState(self.style, self.count);
};

float() SP_func_areaportal =
{
// testing
//	SetAreaPortalState(self.style, 1);
//	return true;
	
	self.use = func_areaportal_use;
	self.count = 0;	// always start closed
	return true;
};


// ===================================================== 

float FUNC_SPAWNFLAG_TRIGGER_SPAWN = 1;
float FUNC_SPAWNFLAG_TOGGLE = 2;
float FUNC_SPAWNFLAG_START_ON = 4;
float FUNC_SPAWNFLAG_ANIMATED = 8;
float FUNC_SPAWNFLAG_ANIMATED_FAST = 16;

/*QUAKED func_object (0 .5 .8) ? TRIGGER_SPAWN X X ANIMATED ANIMATED_FAST
This is solid brush model that will fall if it's support is removed.

"dmg" - damage to apply if it falls on an entity, default 100
*/
void(float planeDist, vector planeNormal, float surfaceFlags) func_object_touch =
{
	// only squash thing we fall on top of
	if (planeNormal = vec3_origin)
		return;
	
	if (planeNormal_z == 1.0)
		return;
	
	if (other.takedamage == DAMAGE_NO)
		return;
	
//	T_Damage (other, self, self, vec3_origin, self.origin, vec3_origin, self.dmg, 1, 0, MOD_CRUSH);
};

void() func_object_release =
{
	self.movetype = MOVETYPE_TOSS;
	self.touch = func_object_touch;
};

void(entity activator) func_object_use =
{
	self.solid = SOLID_BSP;
	self.svflags &= ~SVF_NOCLIENT;
	self.use = null_use;
	KillBox();
	func_object_release();
};

void() SP_func_object =
{
	setmodel(self, self.model); //sets bbox too

	// slightly smaller
	self.mins = self.mins + '1 1 1';
	self.maxs = self.maxs - '1 1 1';

//	self.mins_x += 1;
//	self.mins_y += 1;
//	self.mins_z += 1;
//	self.maxs_x -= 1;
//	self.maxs_y -= 1;
//	self.maxs_z -= 1;

	if( !self.dmg )
		self.dmg = 100;

	if( self.spawnflags == 0 )
	{
		self.solid = SOLID_BSP;
		self.movetype = MOVETYPE_PUSH;
		self.think = func_object_release;
		self.nextthink = g_time + (2 * g_frameTime); // give it two frames so everything could spawn
	}
	else
	{
		self.solid = SOLID_NOT;
		self.movetype = MOVETYPE_PUSH;
		self.use = func_object_use;
		self.svflags |= SVF_NOCLIENT;
	}

	if(self.spawnflags & FUNC_SPAWNFLAG_ANIMATED)
		self.effects |= EF_ANIM_ALL;
	if(self.spawnflags & FUNC_SPAWNFLAG_ANIMATED_FAST)
		self.effects |= EF_ANIM_ALLFAST;

	self.clipmask = MASK_MONSTERSOLID;

	linkentity(self);
}
