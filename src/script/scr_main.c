/*
pragma
Copyright (C) 2023-2024 BraXi.

Quake 2 Engine 'Id Tech 2'
Copyright (C) 1997-2001 Id Software, Inc.

See the attached GNU General Public License v2 for more details.
*/
// scr_main.c

#define PROGS_CHECK_CRC 0

#include "../qcommon/qcommon.h"
#include "script_internals.h"

cvar_t* vm_runaway;

qcvm_t* qcvm[NUM_SCRIPT_VMS];
qcvm_t* active_qcvm; // qcvm currently in use

builtin_t* scr_builtins;
int scr_numBuiltins = 0;

const qcvmdef_t vmDefs[NUM_SCRIPT_VMS] =
{
	{VM_NONE, NULL, 0, "shared"},
	{VM_SVGAME, "progs/svgame.dat", 63850, "svgame"},
	{VM_CLGAME, "progs/cgame.dat", 42847, "clgame"},
	{VM_GUI, "progs/gui.dat", 0, "gui"}
};


#define	G_INT(o)	(*(int *)&active_qcvm->globals[o])

void Cmd_PrintVMEntity_f(void);
void Cmd_PrintAllVMEntities_f(void);

extern void CG_InitScriptBuiltins();
extern void UI_InitScriptBuiltins();
extern void SV_InitScriptBuiltins();

/*
============
Scr_VMName
============
*/
static const char* Scr_VMName(vmType_t vm)
{
	return vmDefs[vm].name;
}

/*
============
ScrInternal_GlobalAtOfs
============
*/
ddef_t* ScrInternal_GlobalAtOfs(int ofs)
{
	ddef_t* def;
	int			i;

	CheckScriptVM(__FUNCTION__);
	for (i = 0; i < active_qcvm->progs->numGlobalDefs; i++)
	{
		def = &active_qcvm->globalDefs[i];
		if (def->ofs == ofs)
			return def;
	}
	return NULL;
}

/*
============
ED_FieldAtOfs
============
*/
ddef_t* ScrInternal_FieldAtOfs(int ofs)
{
	ddef_t	*def;
	int		i;

	CheckScriptVM(__FUNCTION__);
	for (i = 0; i < active_qcvm->progs->numFieldDefs; i++)
	{
		def = &active_qcvm->fieldDefs[i];
		if (def->ofs == ofs)
			return def;
	}
	return NULL;
}

/*
============
Scr_FindEntityField

Returns ddef for an entity field matching name in active qcvm
============
*/
ddef_t* Scr_FindEntityField(char* name)
{
	ddef_t	*def;
	int		i;

	CheckScriptVM(__FUNCTION__);
	for (i = 0; i < active_qcvm->progs->numFieldDefs; i++)
	{
		def = &active_qcvm->fieldDefs[i];
		if (!strcmp(ScrInternal_String(def->s_name), name))
		{
			return def;
		}
	}
	return NULL;
}

/*
=============
Scr_ParseEpair

Can parse either fields or globals, MUST BIND VM BEFORE USE! returns false if error
=============
*/
qboolean Scr_ParseEpair(void* base, ddef_t* key, char* s, int memtag)
{
	int		i;
	char	string[128];
	ddef_t* def;
	char* v, * w;
	void* d;
	scr_func_t func;

	d = (void*)((int*)base + key->ofs);

	switch (key->type & ~DEF_SAVEGLOBAL)
	{
	case ev_string:
		*(scr_string_t*)d = COM_NewString(s, memtag) - active_qcvm->strings;
		break;

	case ev_float:
		*(float*)d = atof(s);
		break;

	case ev_integer:
		*(int*)d = atoi(s);
		break;

	case ev_vector:
		strcpy(string, s);
		v = string;
		w = string;
		for (i = 0; i < 3; i++)
		{
			while (*v && *v != ' ')
				v++;
			*v = 0;
			((float*)d)[i] = atof(w);
			w = v = v + 1;
		}
		break;

	case ev_entity:
		*(int*)d = ENT_TO_VM(ENT_FOR_NUM(atoi(s)));
		break;

	case ev_field:
		def = Scr_FindEntityField(s);
		if (!def)
		{
			//if (strncmp(s, "sky", 3) && strcmp(s, "fog"))
			//	Com_DPrintf(DP_ALL, "Can't find field %s\n", s);
			return false;
		}
		*(int*)d = G_INT(def->ofs);
		break;

	case ev_function:
		func = Scr_FindFunction(s);
		if (func == -1)
		{
			Com_Error(ERR_FATAL, "Can't find function %s\n", s);
			return false;
		}
		*(scr_func_t*)d = func;
		break;

	default:
		break;
	}
	return true;
}

/*
============
Scr_FindGlobal

Returns ddef for a glibal variable in active qcvm
============
*/
ddef_t* Scr_FindGlobal(char* name)
{
	ddef_t* def;
	int			i;

	CheckScriptVM(__FUNCTION__);
	for (i = 0; i < active_qcvm->progs->numGlobalDefs; i++)
	{
		def = &active_qcvm->globalDefs[i];
		if (!strcmp(ScrInternal_String(def->s_name), name))
			return def;
	}
	return NULL;
}


/*
============
Scr_FindFunction

Finds a function with specified name in active qcvm or NULL if not found
============
*/
dfunction_t* ScrInternal_FindFunction(char* name)
{
	dfunction_t* func;
	int				i;

	CheckScriptVM(__FUNCTION__);
	for (i = 0; i < active_qcvm->progs->numFunctions; i++)
	{
		func = &active_qcvm->functions[i];
		if (!strcmp(ScrInternal_String(func->s_name), name))
			return func;
	}
	return NULL;
}


/*
===============
Scr_GenerateBuiltinsDefs

Writes builtins QC header file to disk
===============
*/
void Scr_GenerateBuiltinsDefs(char *filename, pb_t execon)
{
	int i, count = 0;
	FILE* file;

	for (i = 1; i != scr_numBuiltins; i++)
	{
		if (scr_builtins[i].execon == execon)
			count++; //this is naive and lazy
	}

	if (!count)
		return;

	FS_CreatePath(filename);
	file = fopen(filename, "wb");

	if (!file)
	{
		Com_Printf("Failed to open %s for writing.\n", filename);
		return;
	}

	fprintf(file, "// This file was generated by PRAGMA %s (build: %s)", PRAGMA_VERSION, PRAGMA_TIMESTAMP);
	fprintf(file, "// Do not edit, use vm_generatedefs command to rebuild header.\n");
	fprintf(file, "// %i builtin functions.\n\n", count);

	for (i = 1; i != scr_numBuiltins; i++)
	{
		if (scr_builtins[i].execon != execon)
			continue;

		fprintf(file, "%s %s = #%i;\n", scr_builtins[i].qcstring, scr_builtins[i].name, i);
	}

	fclose(file);

	Com_Printf("Generated QC header: %s (%i builtins)\n", filename, count);
}


/*
===============
Scr_LoadProgs

Load qc programs from file and set proper entity size
===============
*/
void Scr_LoadProgs(qcvm_t *vm, char* filename)
{
	int		len, i;
	byte	*raw;

	if (!vm)
		Com_Error(ERR_FATAL, "%s: called but the vm is NULL\n", __FUNCTION__);

	if(vm->progs)
		Com_Error(ERR_FATAL, "%s: tried to load second instance of %s script\n", __FUNCTION__, Scr_VMName(vm->progsType));

	// load file
	len = FS_LoadFile(filename, (void**)&raw);
	if (!len || len == -1)
	{
		Com_Error(ERR_FATAL, "%s: couldn't load \"%s\"\n", __FUNCTION__, filename);
		return;
	}

	vm->progsSize = len;
	vm->progs = (dprograms_t*)raw;
	active_qcvm = vm; // just in case..

	// byte swap the header
	for (i = 0; i < sizeof(*vm->progs) / sizeof(int); i++)
		((int*)vm->progs)[i] = LittleLong(((int*)vm->progs)[i]);

	if (vm->progs->version != PROG_VERSION)
	{
		if (vm->progs->version == PROG_VERSION_FTE)
			Com_Printf("%s: \"%s\" is FTE version and not all opcodes are supported in pragma\n", __FUNCTION__, filename);
		else
			Com_Error(ERR_FATAL, "%s: \"%s\" is wrong version %i (should be %i)\n", __FUNCTION__, filename, vm->progs->version, PROG_VERSION);
	}

	vm->crc = CRC_Block(vm->progs, len);

#if PROGS_CHECK_CRC == 1
	if (vmDefs[vm->progsType].defs_crc_checksum != 0 && vm->progs->crc != vmDefs[vm->progsType].defs_crc_checksum )
	{
		Com_Error(ERR_DROP, "\"%s\" has wrong defs crc = '%i' (recompile progs with up to date headers)\n", filename, vm->progs->crc);
		return;
	}
#else
	Com_Printf("PROGS CRC CHECK DISABLED, %s CRC checksum is %i\n", filename, vm->crc);
#endif

	// cast the data from progs
	vm->functions = (dfunction_t*)((byte*)vm->progs + vm->progs->ofs_functions);
	vm->strings = (char*)vm->progs + vm->progs->ofs_strings;
	vm->globalDefs = (ddef_t*)((byte*)vm->progs + vm->progs->ofs_globaldefs);
	vm->fieldDefs = (ddef_t*)((byte*)vm->progs + vm->progs->ofs_fielddefs);
	vm->statements = (dstatement_t*)((byte*)vm->progs + vm->progs->ofs_statements);
	vm->globals_struct =((byte*)vm->progs + vm->progs->ofs_globals);	
	vm->globals = (float*)vm->globals_struct;
	vm->entity_size = vm->entity_size + (vm->progs->entityfields * 4);

	// byte swap all the data
	for (i = 0; i < vm->progs->numStatements; i++)
	{
		vm->statements[i].op = LittleShort(vm->statements[i].op);
		vm->statements[i].a = LittleShort(vm->statements[i].a);
		vm->statements[i].b = LittleShort(vm->statements[i].b);
		vm->statements[i].c = LittleShort(vm->statements[i].c);
	}
	for (i = 0; i < vm->progs->numFunctions; i++)
	{
		vm->functions[i].first_statement = LittleLong(vm->functions[i].first_statement);
		vm->functions[i].parm_start = LittleLong(vm->functions[i].parm_start);
		vm->functions[i].s_name = LittleLong(vm->functions[i].s_name);
		vm->functions[i].s_file = LittleLong(vm->functions[i].s_file);
		vm->functions[i].numparms = LittleLong(vm->functions[i].numparms);
		vm->functions[i].locals = LittleLong(vm->functions[i].locals);
	}

	for (i = 0; i < vm->progs->numGlobalDefs; i++)
	{
		vm->globalDefs[i].type = LittleShort(vm->globalDefs[i].type);
		vm->globalDefs[i].ofs = LittleShort(vm->globalDefs[i].ofs);
		vm->globalDefs[i].s_name = LittleLong(vm->globalDefs[i].s_name);
	}

	for (i = 0; i < vm->progs->numFieldDefs; i++)
	{
		vm->fieldDefs[i].type = LittleShort(vm->fieldDefs[i].type);
		if (vm->fieldDefs[i].type & DEF_SAVEGLOBAL)
			Com_Error(ERR_FATAL, "pr_fielddefs[%i].type & DEF_SAVEGLOBAL\n", i);

		vm->fieldDefs[i].ofs = LittleShort(vm->fieldDefs[i].ofs);
		vm->fieldDefs[i].s_name = LittleLong(vm->fieldDefs[i].s_name);
	}

	for (i = 0; i < vm->progs->numGlobals; i++)
		((int*)vm->globals)[i] = LittleLong(((int32_t*)vm->globals)[i]);
}

/*
===============
Scr_OpenLogFileForVM

Opens a logfile for qcvm in developer mode, this allows logprint() to save to disk
===============
*/
static void Scr_OpenLogFileForVM(qcvm_t *vm)
{
	char name[MAX_OSPATH];

//	if (vm->logfile)
//	{
//		Com_Printf("closed logfile %s\n");
//		fclose(vm->logfile);
//		vm->logfile = NULL;
//		return;
//	}

	if (!developer->value)
		return;

	sprintf(name, "%s/%s.log", FS_Gamedir(), Scr_VMName(vm->progsType));

	vm->logfile = fopen(name, "w");
	if (!vm->logfile)
		return;

	Com_Printf("opened logfile: %s\n", name);

	fprintf(vm->logfile, "---- opened logfile %s ----\n", GetTimeStamp(true));
	fflush(active_qcvm->logfile);
}

/*
===============
Scr_CreateScriptVM

Create script execution context
===============
*/

void Scr_CreateScriptVM(vmType_t vmType, unsigned int numEntities, size_t entitySize, size_t entvarOfs)
{
	Scr_BindVM(VM_NONE);
	Scr_FreeScriptVM(vmType);

//	if (qcvm[progsType] != NULL)
//		Com_Error(ERR_FATAL, "Tried to create second instance of %s script VM\n", Scr_VMName(progsType));

	qcvm[vmType] = Z_Malloc(sizeof(qcvm_t));
	if (qcvm == NULL)
		Com_Error(ERR_FATAL, "Couldn't allocate %s script VM\n", Scr_VMName(vmType));

	qcvm_t* vm = qcvm[vmType];
	vm = qcvm[vmType];
	vm->progsType = vmType;

	vm->num_entities = numEntities;
	vm->offsetToEntVars = entvarOfs;
	vm->entity_size = entitySize; // invaild now, will be set properly in loadprogs

	// load progs from file
	Scr_LoadProgs(vm, vmDefs[vmType].filename);

	// allocate entities
	vm->entities = (vm_entity_t*)Z_Malloc(vm->num_entities * vm->entity_size);
	if (vm->entities == NULL)
		Com_Error(ERR_FATAL, "Couldn't allocate entities for %s script VM\n", Scr_VMName(vmType));

	// open devlog
	Scr_OpenLogFileForVM(vm);

	// print statistics
	dprograms_t* progs = vm->progs;
	Com_Printf("-------------------------------------\n");
	Com_Printf("%s qcvm: '%s'\n", Scr_VMName(vm->progsType), vmDefs[vmType].filename);
	Com_Printf("          Functions: %i\n", progs->numFunctions);
	Com_Printf("         Statements: %i\n", progs->numStatements);
	Com_Printf("         GlobalDefs: %i\n", progs->numGlobalDefs);
	Com_Printf("            Globals: %i\n", progs->numGlobals);
	Com_Printf("      Entity fields: %i\n", progs->numFieldDefs);
	Com_Printf(" Allocated entities: %i, %i bytes\n", vm->num_entities, vm->num_entities * Scr_GetEntitySize());
	Com_Printf("        Entity size: %i bytes\n", Scr_GetEntitySize());
	Com_Printf("\n");
	Com_Printf("       CRC checksum: %i\n", vm->crc);
	Com_Printf("      Programs size: %i bytes (%iKb)\n", vm->progsSize, vm->progsSize / 1024);
	Com_Printf("-------------------------------------\n");
}

/*
===============
Scr_DestroyScriptVM

Destroy QC virtual machine
===============
*/
void Scr_FreeScriptVM(vmType_t vmtype)
{
	qcvm_t *vm = qcvm[vmtype];

	if (!vm)
		return;

	if (vm->entities)
		Z_Free(vm->entities);

	if (vm->progs)
		Z_Free(vm->progs);

	if (vm->logfile)
	{
		fprintf(vm->logfile, "---- closed logfile %s ----\n", GetTimeStamp(true));
		fclose(vm->logfile);
		vm->logfile = NULL;
	}

	if (vm->progsType == VM_CLGAME)
	{
		Cmd_RemoveClientGameCommands();
	}

	Z_Free(vm);
	qcvm[vmtype] = NULL;

	Scr_BindVM(VM_NONE);
	Com_Printf("Freed %s script...\n", Scr_VMName(vmtype));
}

#if 0
void Cmd_Script_PrintFunctions(void)
{
	qcvm_t* vm = active_qcvm;
	if (!vm)
		return;

	for (int i = scr_numBuiltins; i < vm->progs->numFunctions; i++) // unsafe start
	{
		char* srcFile = ScrInternal_String(vm->functions[i].s_file);
		char* funcName = ScrInternal_String(vm->functions[i].s_name);
		int numParms = (vm->functions[i].numparms);
		if (numParms)
			printf("#%i %s:%s(#%i)\n", i, srcFile, funcName, numParms);
		else
			printf("#%i %s:%s()\n", i, srcFile, funcName);
	}
}
#endif

/*
===============
Scr_IsVMLoaded

Return true if a specified qcvm is loaded
===============
*/
qboolean Scr_IsVMLoaded(vmType_t vmtype)
{
	if (qcvm[vmtype] == NULL)
		return false;
	return true;
}

/*
===============
Scr_BindVM

Select (bind) QCVM for use, this is important for Get/Set/Call/Return scr functions
===============
*/
void Scr_BindVM(vmType_t vmtype)
{
	if (qcvm[vmtype] == NULL)
		return;
	active_qcvm = qcvm[vmtype];
	CheckScriptVM(__FUNCTION__);
}

/*
===============
Scr_GetGlobals
===============
*/
void* Scr_GetGlobals()
{
	CheckScriptVM(__FUNCTION__);
	return active_qcvm->globals_struct;
}

/*
===============
Scr_GetEntitySize
===============
*/
int Scr_GetEntitySize()
{
	CheckScriptVM(__FUNCTION__);
	return (int)active_qcvm->entity_size;
}

/*
===============
Scr_GetEntityPtr
===============
*/
vm_entity_t* Scr_GetEntityPtr()
{
	CheckScriptVM(__FUNCTION__);
	return active_qcvm->entities;
}

/*
===============
Scr_GetProgsCRC
===============
*/
extern unsigned Scr_GetProgsCRC(vmType_t vmType)
{
	if (qcvm[vmType] == NULL)
		return 0;
	return qcvm[vmType]->crc;
}

/*
===============
Scr_GetEntityFieldsSize
===============
*/
int Scr_GetEntityFieldsSize()
{
	CheckScriptVM(__FUNCTION__);
	return (active_qcvm->progs->entityfields * 4);
}

/*
===============
Cmd_VM_GenerateDefs_f

vm_generatedefs command
===============
*/
void Cmd_VM_GenerateDefs_f(void)
{
	if (!developer->value)
	{
		Com_Printf("developer mode must be enabled for 'vm_generatedefs'\n");
		return;
	}

	for (vmType_t type = 0; type < NUM_SCRIPT_VMS; type++)
	{
		// always write to current gamedir/moddir
		Scr_GenerateBuiltinsDefs(va("%s/progs_src/inc/pragma_funcs_%s.qc", FS_Gamedir(), vmDefs[type].name), type);
	}
}

/*
===============
Scr_PreInitVMs

initialize qcvms builtin functions, commands and cvars
===============
*/
void Scr_PreInitVMs()
{
	vmType_t type;
	active_qcvm = NULL;

	for (type = 0; type < NUM_SCRIPT_VMS; type++)
		qcvm[type] = NULL;

	scr_numBuiltins = 0;
	Scr_InitSharedBuiltins();
	CG_InitScriptBuiltins();
	UI_InitScriptBuiltins();
	SV_InitScriptBuiltins();

	vm_runaway = Cvar_Get("vm_runaway", va("%i", VM_DEFAULT_RUNAWAY), 0, "Count of executed QC instructions to trigger runaway error.");

	// add developer comands
	Cmd_AddCommand("vm_printent", Cmd_PrintVMEntity_f);
	Cmd_AddCommand("vm_printents", Cmd_PrintAllVMEntities_f);
//	Cmd_AddCommand("vm_reload", cmd_vm_reload_f);
	Cmd_AddCommand("vm_generatedefs", Cmd_VM_GenerateDefs_f);
}

/*
===============
Scr_Shutdown

free all qcvms and associated builtins
===============
*/
void Scr_Shutdown()
{
	Scr_BindVM(VM_NONE);

	Cmd_RemoveCommand("vm_printent");
	Cmd_RemoveCommand("vm_printents");

	if (scr_builtins)
	{
		Z_Free(scr_builtins);
		scr_builtins = NULL;
		Com_DPrintf(DP_SCRIPT, "Freed script VM builtins...\n");
	}

	for (vmType_t i = 1; i < NUM_SCRIPT_VMS; i++)
	{
		if(qcvm[i])
			Scr_FreeScriptVM(i);
	}
}

#ifndef DEDICATED_ONLY
typedef enum
{
	XALIGN_NONE = 0,
	XALIGN_LEFT = 0,
	XALIGN_RIGHT = 1,
	XALIGN_CENTER = 2
} UI_AlignX;
void UI_DrawString(int x, int y, UI_AlignX alignx, char* string);

void PR_Profile(int x, int y)
{
	dfunction_t* f, * best;
	int			max;
	int			num;
	int			i;
	static int nexttime = 0;

	static char str[10][96];

	if (Sys_Milliseconds() > nexttime + 100)
	{
		nexttime = Sys_Milliseconds();
		memset(&str, 0, sizeof(str));
		num = 0;
		do
		{
			max = 0;
			best = NULL;
			for (i = 0; i < active_qcvm->progs->numFunctions; i++)
			{
				f = &active_qcvm->functions[i];
				if (f->profile > max)
				{
					max = f->profile;
					best = f;
				}
			}
			if (best)
			{
				if (num < 10)
				{
					Com_sprintf(str[num], sizeof(str[num]), "%7i %s in %s", best->profile, ScrInternal_String(best->s_name), ScrInternal_String(best->s_file));
					Com_sprintf(str[num], sizeof(str[num]), "%7i:%s", best->profile, ScrInternal_String(best->s_name));
					//Com_Printf(str[num]);
					//UI_DrawString(x, y, XALIGN_RIGHT, str[num]);
				}

				num++;
				best->profile = 0;
			}
		} while (best);
	}

	for(i = 0; i < 10; i++)
		UI_DrawString(x, y+10*i, XALIGN_RIGHT, str[i]);
}

#endif
